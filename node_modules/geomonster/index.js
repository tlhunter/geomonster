var GeoMonster = function() {
	var self = this;

	/**
	 * How many seconds between each monster movement do we want to wait? All monsters move simultaneously.
	 */
	var monster_move_wait_seconds = 4;

	/**
	 * socket.io reference
	 */
	var io = null;

	var monster_max_move = {
		lat: 0.0001,
		lon: 0.0001,
	};

	/**
	 * This is the bounding box for which players and monsters need to stay and spawn
	 * Michigan: Lansing, Ann Arbor, Detroit, Jackson, Troy
	 */
	var bounds = {
		min: {
			lat: 42.0000,
			lon: -85.0000,
		},
		max: {
			lat: 43.0000,
			lon: -83.0000,
		}
	};

	var monster_types = {
		0: { name: 'Shade [Special]', wild: false, begin_level: 3 },
		1: { name: 'Skeleton [Special]', wild: false, begin_level: 3 },
		2: { name: 'Goblin [Special]', wild: false, begin_level: 3 },

		3: { name: 'Imp', wild: true, begin_level: 1 },
		4: { name: 'Dijin', wild: true, begin_level: 1 },
		5: { name: 'Seductress', wild: true, begin_level: 1 },
		6: { name: 'Grimm', wild: true, begin_level: 2 },
		7: { name: 'Viking', wild: true, begin_level: 3 },
	};

	var spawnable_monster_ids = [];

	for (var index in monster_types) {
		var current_monster = monster_types[index];
		if (current_monster.wild) {
			spawnable_monster_ids.push(index);
		}
	}

	var monsters = [];

	var players = [];

	var monster_move_timer = null;

	/**
	 * sets the socket.io handler
	 */
	self.setSockets = function(passed_in_io) {
		io = passed_in_io;
		return self;
	};

	/**
	 * Creates the initial population of all monsters
	 */
	self.initializeMonsterPopulation = function(count) {
		for (var i = 0; i < count; i++) {
			var monster_type = self.getIdForRandomSpawnableMonster();
			monsters.push({
				coords: self.getRandomLocationWithinBounds(),
				type: monster_type,
				level: monster_types[monster_type].begin_level,
				wild: true,
			});
		}
		return self;
	};

	/**
	 * Begins the movement timer for moving all monsters
	 */
	self.initializeMonsterMovement = function() {
		monster_move_timer = setInterval(self.moveMonsters, 1000 * monster_move_wait_seconds);
		return self;
	};

	/**
	 * Randomly moves all monsters a small about
	 */
	self.moveMonsters = function() {
		var number_of_monsters = monsters.length;
		console.log("[EVENT] Beginning global monster movement for " + number_of_monsters + " monsters...");
		var new_coords = null;
		for (var i = 0; i < number_of_monsters; i++) {
			new_coords = {
				lat: monsters[i].coords.lat + Math.random()*monster_max_move.lat - monster_max_move.lat/2,
				lon: monsters[i].coords.lon + Math.random()*monster_max_move.lon - monster_max_move.lon/2,
			};
			if (self.checkIfLocationWithinBounds(new_coords)) {
				monsters[i].coords = new_coords;
			}
		}
		console.log("[EVENT] Global monster movement complete.");
		io.sockets.emit('monster-move', monsters);
	};

	/**
	 * Ends the monster movement timer, probably not ever needed, but nice to have
	 */
	self.killMonsterMovement = function() {
		clearTimeout(monster_move_timer);
	};

	/**
	 * Gets all instances of monsters in the world
	 */
	self.getAllMonsters = function() {
		return monsters;
	};

	/**
	 * Returns a list of monster types
	 */
	self.getMonsterTypes = function() {
		return monster_types;
	};

	/**
	 * Returns a random id for a monster chich can spawn
	 */
	self.getIdForRandomSpawnableMonster = function() {
		return parseInt(spawnable_monster_ids[Math.floor(Math.random()*spawnable_monster_ids.length)], 10);
	};

	/**
	 * Returns a location within our bounding box. It's an object with a lat/lon pair, that's it.
	 */
	self.getRandomLocationWithinBounds = function() {
		return {
			lat: (Math.random() * (bounds.max.lat - bounds.min.lat)) + bounds.min.lat,
			lon: (Math.random() * (bounds.max.lon - bounds.min.lon)) + bounds.min.lon,
		};
	};

	/**
	 * Checks to see if the provided location is within our bounding box.
	 */
	self.checkIfLocationWithinBounds = function(c) {
		return c.lat >= bounds.min.lat && c.lat <= bounds.max.lat && c.lon >= bounds.min.lon && c.lon <= bounds.max.lon;
	};
};

module.exports = new GeoMonster();
