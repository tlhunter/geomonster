var monster_types = require('./monsters.json');

var GeoMonster = function() {
	var self = this;

	/**
	 * How many seconds between each monster movement do we want to wait? All monsters move simultaneously.
	 */
	var MONSTER_MOVE_WAIT_SECONDS = 2;

	/**
	 * socket.io reference
	 */
	var io = null;

	// Farthest distance a monster can move
	var MONSTER_MAX_MOVE = {
		lat: 0.0001,
		lon: 0.0001,
	};

	// Area in which monsters will be sent to the particular player
	var MONSTER_DATA_THRESHOLD = {
		lat: 0.002,
		lon: 0.006,
	};

	/**
	 * This is the bounding box for which players and monsters need to stay and spawn
	 * Michigan:: min: { lat: 41.705729, lon: -86.989746, }, max: { lat: 45.813486, lon: -82.397461, }
	 * Lansing & Ann Arbor:: min: { lat: 42.167475, lon: -84.765015, }, max: { lat: 42.871938, lon: -83.512573, }
	 */
	var BOUNDS = {
		min: {
			lat: 42.167475,
			lon: -84.765015,
		},
		max: {
			lat: 42.871938,
			lon: -83.512573,
		}
	};

	var spawnable_monster_ids = [];

	for (var index in monster_types) {
		var current_monster = monster_types[index];
		if (current_monster.wild) {
			spawnable_monster_ids.push(index);
		}
	}

	var monsters = {};
	var players = {};

	var monster_move_timer = null;

	/**
	 * sets the socket.io handler
	 */
	self.setSockets = function(passed_in_io) {
		io = passed_in_io;
		io.sockets.on('connection', function(socket) {
			var user_id = null;
			var in_room = false;
			socket.on('location', function(coords) {
				if (typeof players[coords.user_id] === 'undefined') {
					players[coords.user_id] = coords;
					players[coords.user_id].online = true;
					user_id = coords.user_id;
					console.log("PLAYER JOINED FOR FIRST TIME: " + user_id);
				}
				if (players[coords.user_id].online == false) {
					user_id = coords.user_id;
					players[coords.user_id].online = true;
					console.log("EXISTING PLAYER HAS COME BACK: " + user_id);
				}
				players[coords.user_id].lat = coords.lat;
				players[coords.user_id].lon = coords.lon;
				console.log("NEW COORDINATES: ", coords);
				io.sockets.emit('player-move', players[coords.user_id] );
				if (!in_room) socket.join('player-' + coords.user_id);
			});
			socket.on('disconnect', function() {
				if(typeof coords !== 'undefined') {
					players[coords.user_id].online = false;
					console.log("PLAYER HAS DISCONNECTED: " + user_id);
				}
			});
			socket.on('monster-kill', function(data) {
				if (monsters[data.monster_id]) {
					delete monsters[data.monster_id];
					io.sockets.emit('monster-kill', data);
				}
			});
		});
		return self;
	};

	/**
	 * Creates the initial population of all monsters
	 */
	self.initializeMonsterPopulation = function(count) {
		for (var i = 0; i < count; i++) {
			var monster_type = self.getIdForRandomSpawnableMonster();
			monsters[i] = {
				coords: self.getRandomLocationWithinBounds(),
				type: monster_type,
				level: monster_types[monster_type].begin_level,
				wild: true,
			};
		}
		return self;
	};

	/**
	 * Begins the movement timer for moving all monsters
	 */
	self.initializeMonsterMovement = function() {
		monster_move_timer = setInterval(self.moveMonsters, 1000 * MONSTER_MOVE_WAIT_SECONDS);
		return self;
	};

	/**
	 * Randomly moves all monsters a small about
	 */
	self.moveMonsters = function() {
		var new_coords = null;
		for (var index in monsters) {
			if (typeof monsters[index] === 'undefined') continue;
			new_coords = {
				lat: monsters[index].coords.lat + Math.random()*MONSTER_MAX_MOVE.lat - MONSTER_MAX_MOVE.lat/2,
				lon: monsters[index].coords.lon + Math.random()*MONSTER_MAX_MOVE.lon - MONSTER_MAX_MOVE.lon/2,
			};
			if (self.checkIfLocationWithinBounds(new_coords)) {
				monsters[index].coords = new_coords;
			}
		}

		// This sends all monster data to all players
		//io.sockets.emit('monster-move', monsters);

		// however, we'd rather just send some monster data to players that are near them
		var player, monsters_i_care_about, monster, player_id, monster_id;
		for (player_id in players) {
			player = players[player_id];
			monsters_i_care_about = {};
			for (monster_id in monsters) {
				monster = monsters[monster_id];
				if (
					monster.coords.lat >= player.lat - MONSTER_DATA_THRESHOLD.lat &&
					monster.coords.lat <= player.lat + MONSTER_DATA_THRESHOLD.lat &&
					monster.coords.lon >= player.lon - MONSTER_DATA_THRESHOLD.lon &&
					monster.coords.lon <= player.lon + MONSTER_DATA_THRESHOLD.lon
				) {
					monsters_i_care_about[monster_id] = monster;
				}
			}
			io.sockets.in('player-'+player_id).emit('monster-move', monsters_i_care_about);
		}
	};

	/**
	 * Ends the monster movement timer, probably not ever needed, but nice to have
	 */
	self.killMonsterMovement = function() {
		clearTimeout(monster_move_timer);
	};

	/**
	 * Gets all instances of monsters in the world
	 */
	self.getAllMonsters = function() {
		return monsters;
	};

	/**
	 * Gets all instances of players in the world
	 */
	self.getAllPlayers = function() {
		return players;
	};

	/**
	 * Returns a list of monster types
	 */
	self.getMonsterTypes = function() {
		return monster_types;
	};

	/**
	 * Returns a random id for a monster chich can spawn
	 */
	self.getIdForRandomSpawnableMonster = function() {
		return parseInt(spawnable_monster_ids[Math.floor(Math.random()*spawnable_monster_ids.length)], 10);
	};

	/**
	 * Returns a location within our bounding box. It's an object with a lat/lon pair, that's it.
	 */
	self.getRandomLocationWithinBounds = function() {
		return {
			lat: (Math.random() * (BOUNDS.max.lat - BOUNDS.min.lat)) + BOUNDS.min.lat,
			lon: (Math.random() * (BOUNDS.max.lon - BOUNDS.min.lon)) + BOUNDS.min.lon,
		};
	};

	/**
	 * Checks to see if the provided location is within our bounding box.
	 */
	self.checkIfLocationWithinBounds = function(c) {
		return c.lat >= BOUNDS.min.lat && c.lat <= BOUNDS.max.lat && c.lon >= BOUNDS.min.lon && c.lon <= BOUNDS.max.lon;
	};
};

module.exports = new GeoMonster();
