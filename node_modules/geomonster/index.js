var monster_types = require('./monsters.json');

var GeoMonster = function() {
	var self = this;

	/**
	 * How many seconds between each monster movement do we want to wait? All monsters move simultaneously.
	 */
	var MONSTER_MOVE_WAIT_SECONDS = 1;

	/**
	 * socket.io reference
	 */
	var io = null;

	var MONSTER_MAX_MOVE = {
		lat: 0.0001,
		lon: 0.0001,
	};

	var MONSTER_DATA_THRESHOLD = {
		lat: 0.005,
		lon: 0.005,
	};

	/**
	 * This is the bounding box for which players and monsters need to stay and spawn
	 * Michigan: Lansing, Ann Arbor, Detroit, Jackson, Troy
	 */
	var BOUNDS = {
		min: { // upper left
			lat: 42.706155,
			lon: -84.522285,
		},
		max: { // lower right
			lat: 42.742474,
			lon: -84.451561,
		}
	};

	var spawnable_monster_ids = [];

	for (var index in monster_types) {
		var current_monster = monster_types[index];
		if (current_monster.wild) {
			spawnable_monster_ids.push(index);
		}
	}

	var monsters = {};
	var players = {};

	var monster_move_timer = null;

	/**
	 * sets the socket.io handler
	 */
	self.setSockets = function(passed_in_io) {
		io = passed_in_io;
		io.sockets.on('connection', function(socket) {
			var user_id = null;
			socket.on('location', function(coords) {
				if (typeof players[coords.user_id] === 'undefined') {
					players[coords.user_id] = coords;
					players[coords.user_id].online = true;
					user_id = coords.user_id;
					console.log("PLAYER JOINED FOR FIRST TIME: " + user_id);
				}
				if (players[coords.user_id].online == false) {
					user_id = coords.user_id;
					players[coords.user_id].online = true;
					console.log("EXISTING PLAYER HAS COME BACK: " + user_id);
				}
				players[coords.user_id].lat = coords.lat;
				players[coords.user_id].lon = coords.lon;
				console.log("NEW COORDINATES: ", coords);
				io.sockets.emit('player-move', players[coords.user_id] );
			});
			socket.on('disconnect', function() {
				if(typeof coords !== 'undefined') {
					players[coords.user_id].online = false;
					console.log("PLAYER HAS DISCONNECTED: " + user_id);
				}
			});
			socket.on('monster-kill', function(data) {
				if (monsters[data.monster_id]) {
					delete monsters[data.monster_id];
					io.sockets.emit('monster-kill', data);
				}
			});
		});
		return self;
	};

	/**
	 * Creates the initial population of all monsters
	 */
	self.initializeMonsterPopulation = function(count) {
		for (var i = 0; i < count; i++) {
			var monster_type = self.getIdForRandomSpawnableMonster();
			monsters[i] = {
				coords: self.getRandomLocationWithinBounds(),
				type: monster_type,
				level: monster_types[monster_type].begin_level,
				wild: true,
			};
		}
		return self;
	};

	/**
	 * Begins the movement timer for moving all monsters
	 */
	self.initializeMonsterMovement = function() {
		monster_move_timer = setInterval(self.moveMonsters, 1000 * MONSTER_MOVE_WAIT_SECONDS);
		return self;
	};

	/**
	 * Randomly moves all monsters a small about
	 */
	self.moveMonsters = function() {
		//console.log("[EVENT] Beginning global monster movement for " + number_of_monsters + " monsters...");
		var new_coords = null;
		for (var index in monsters) {
			if (typeof monsters[index] === 'undefined') continue;
			new_coords = {
				lat: monsters[index].coords.lat + Math.random()*MONSTER_MAX_MOVE.lat - MONSTER_MAX_MOVE.lat/2,
				lon: monsters[index].coords.lon + Math.random()*MONSTER_MAX_MOVE.lon - MONSTER_MAX_MOVE.lon/2,
			};
			if (self.checkIfLocationWithinBounds(new_coords)) {
				monsters[index].coords = new_coords;
			}
		}
		//console.log("[EVENT] Global monster movement complete.");
		io.sockets.emit('monster-move', monsters);
	};

	/**
	 * Ends the monster movement timer, probably not ever needed, but nice to have
	 */
	self.killMonsterMovement = function() {
		clearTimeout(monster_move_timer);
	};

	/**
	 * Gets all instances of monsters in the world
	 */
	self.getAllMonsters = function() {
		return monsters;
	};

	/**
	 * Gets all instances of players in the world
	 */
	self.getAllPlayers = function() {
		return players;
	};

	/**
	 * Returns a list of monster types
	 */
	self.getMonsterTypes = function() {
		return monster_types;
	};

	/**
	 * Returns a random id for a monster chich can spawn
	 */
	self.getIdForRandomSpawnableMonster = function() {
		return parseInt(spawnable_monster_ids[Math.floor(Math.random()*spawnable_monster_ids.length)], 10);
	};

	/**
	 * Returns a location within our bounding box. It's an object with a lat/lon pair, that's it.
	 */
	self.getRandomLocationWithinBounds = function() {
		return {
			lat: (Math.random() * (BOUNDS.max.lat - BOUNDS.min.lat)) + BOUNDS.min.lat,
			lon: (Math.random() * (BOUNDS.max.lon - BOUNDS.min.lon)) + BOUNDS.min.lon,
		};
	};

	/**
	 * Checks to see if the provided location is within our bounding box.
	 */
	self.checkIfLocationWithinBounds = function(c) {
		return c.lat >= BOUNDS.min.lat && c.lat <= BOUNDS.max.lat && c.lon >= BOUNDS.min.lon && c.lon <= BOUNDS.max.lon;
	};
};

module.exports = new GeoMonster();
